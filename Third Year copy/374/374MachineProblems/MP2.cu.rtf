{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red89\green138\blue67;\red23\green23\blue23;\red202\green202\blue202;
\red70\green137\blue204;\red194\green126\blue101;\red167\green197\blue152;}
{\*\expandedcolortbl;;\cssrgb\c41569\c60000\c33333;\cssrgb\c11765\c11765\c11765;\cssrgb\c83137\c83137\c83137;
\cssrgb\c33725\c61176\c83922;\cssrgb\c80784\c56863\c47059;\cssrgb\c70980\c80784\c65882;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 //Evan Cohen 20214967 \cf4 \cb1 \strokec4 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 #include \cf6 \strokec6 <cstdio>\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 #include \cf6 \strokec6 <cstdlib>\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 #include \cf6 \strokec6 <cuda_runtime.h>\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 #include \cf6 \strokec6 <ctime>\cf4 \cb1 \strokec4 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // tolerance for floating point equality\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 #define TOLERANCE \cf7 \strokec7 1e-6\cf4 \cb1 \strokec4 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 __global__ \cf5 \strokec5 void\cf4 \strokec4  matrix_add_element(\cf5 \strokec5 float\cf4 \strokec4  *c, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float\cf4 \strokec4  *a, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float\cf4 \strokec4  *b, \cf5 \strokec5 int\cf4 \strokec4  num) \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Determine block and thread indices\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 int\cf4 \strokec4  row = blockIdx.y * blockDim.y + threadIdx.y;\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 int\cf4 \strokec4  col = blockIdx.x * blockDim.x + threadIdx.x;\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Add the corresponding elements of A and B\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 if\cf4 \strokec4  (col < num && row < num) \{\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 c[row*num + col] = a[row*num + col] + b[row*num + col];\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\cb3 \}\cb1 \
\
\
\
\cb3 __global__ \cf5 \strokec5 void\cf4 \strokec4  matrix_add_rows(\cf5 \strokec5 float\cf4 \strokec4  *c, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float\cf4 \strokec4  *a, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float\cf4 \strokec4  *b, \cf5 \strokec5 int\cf4 \strokec4  num) \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Determine row value\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 int\cf4 \strokec4  row = blockIdx.y * blockDim.y + threadIdx.y;\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Add the corresponding elements of A and B if row value is valid\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 if\cf4 \strokec4  (row < num) \{\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  i = \cf7 \strokec7 0\cf4 \strokec4 ; i < num; i++) \{\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 c[row*num + i] = a[row*num + i] + b[row*num + i];\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\
\cb3 \}\cb1 \
\
\
\
\cb3 __global__ \cf5 \strokec5 void\cf4 \strokec4  matrix_add_cols(\cf5 \strokec5 float\cf4 \strokec4  *c, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float\cf4 \strokec4  *a, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float\cf4 \strokec4  *b,  \cf5 \strokec5 int\cf4 \strokec4  num) \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Determine column value\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 int\cf4 \strokec4  col = blockIdx.x * blockDim.x + threadIdx.x;\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Add the corresponding elements of A and B if column value is valid\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 if\cf4 \strokec4  (col < num) \{\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  i = \cf7 \strokec7 0\cf4 \strokec4 ;i < num; i++) \{\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 c[i*num + col] = a[i*num + col] + b[i*num + col];\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\
\cb3 \}\cb1 \
\
\
\
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 void\cf4 \strokec4  matrixAddition(\cf5 \strokec5 float*\cf4 \strokec4  C, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4  A, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4  B, \cf5 \strokec5 int\cf4 \strokec4  width, \cf5 \strokec5 void\cf4 \strokec4 (*kernel)(\cf5 \strokec5 float*\cf4 \strokec4 , \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4 , \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4 , \cf5 \strokec5 int\cf4 \strokec4 ), dim3 gridDim, dim3 blockDim) \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Allocate device memory\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 float\cf4 \strokec4 * deviceA, *deviceB, *deviceC;\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Allocate memory for the matrices on the host\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 size_t\cf4 \strokec4  size = width * width * \cf5 \strokec5 sizeof\cf4 \strokec4 (\cf5 \strokec5 float\cf4 \strokec4 );\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Allocate memory on the device\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaMalloc((\cf5 \strokec5 void\cf4 \strokec4 **)&deviceA, size);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaMalloc((\cf5 \strokec5 void\cf4 \strokec4 **)&deviceB, size);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaMalloc((\cf5 \strokec5 void\cf4 \strokec4 **)&deviceC, size);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Copy data from the host to the device\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaMemcpy(deviceA, A, size, cudaMemcpyHostToDevice);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaMemcpy(deviceB, B, size, cudaMemcpyHostToDevice);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Create events for timing\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEvent_t start, stop;\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEventCreate(&start);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEventCreate(&stop);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEventRecord(start, \cf7 \strokec7 0\cf4 \strokec4 );\cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Execute the kernel\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 kernel << <gridDim, blockDim >> >(deviceC, deviceA, deviceB, width);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Wait for the kernel to finish\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEventRecord(stop, \cf7 \strokec7 0\cf4 \strokec4 );\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEventSynchronize(stop);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Calculate the elapsed time\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 float\cf4 \strokec4  elapsedTime;\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaEventElapsedTime(&elapsedTime, start, stop);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Copy data from the device to the host\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaMemcpy(C, deviceC, size, cudaMemcpyDeviceToHost);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Free device memory\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaFree(deviceA);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaFree(deviceB);\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 cudaFree(deviceC);\cb1 \
\
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Kernel execution time: %f ms\\n"\cf4 \strokec4 , elapsedTime);\cb1 \
\
\cb3 \}\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // CPU implementation of matrix addition\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 void\cf4 \strokec4  matrixAddition_CPU(\cf5 \strokec5 float*\cf4 \strokec4  C, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4  A, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4  B, \cf5 \strokec5 int\cf4 \strokec4  width) \{ \cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  row = \cf7 \strokec7 0\cf4 \strokec4 ; row < width; ++row) \{\cb1 \
\cb3         \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  col = \cf7 \strokec7 0\cf4 \strokec4 ; col < width; ++col) \{\cb1 \
\cb3             \cf5 \strokec5 int\cf4 \strokec4  index = row * width + col;\cb1 \
\cb3             C[index] = A[index] + B[index];\cb1 \
\cb3         \}\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 bool\cf4 \strokec4  testResults(\cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4  A, \cf5 \strokec5 const\cf4 \strokec4  \cf5 \strokec5 float*\cf4 \strokec4  B, \cf5 \strokec5 int\cf4 \strokec4  width) \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  i = \cf7 \strokec7 0\cf4 \strokec4 ; i < width * width; i++) \{\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 if\cf4 \strokec4  (fabs(A[i] - B[i])>\cf5 \strokec5 TOLERANCE\cf4 \strokec4 ) \{\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 false\cf4 \strokec4 ;\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 return\cf4 \strokec4  \cf5 \strokec5 true\cf4 \strokec4 ;\cb1 \
\cb3 \}\cb1 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 int\cf4 \strokec4  main() \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 int\cf4 \strokec4  matrixSize[] = \{ \cf7 \strokec7 125\cf4 \strokec4 ,\cf7 \strokec7 250\cf4 \strokec4 ,\cf7 \strokec7 500\cf4 \strokec4 ,\cf7 \strokec7 1000\cf4 \strokec4 ,\cf7 \strokec7 2000\cf4 \strokec4  \};\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Loop over the matrix sizes\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  i = \cf7 \strokec7 0\cf4 \strokec4 ; i < \cf7 \strokec7 5\cf4 \strokec4 ; ++i) \{\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 int\cf4 \strokec4  width = matrixSize[i];\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "\\nMatrix size: %d x %d\\n"\cf4 \strokec4 , width, width);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 // Allocate memory for the matrices\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 float\cf4 \strokec4 * A = (\cf5 \strokec5 float\cf4 \strokec4 *)malloc(width * width * \cf5 \strokec5 sizeof\cf4 \strokec4 (\cf5 \strokec5 float\cf4 \strokec4 ));\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 float\cf4 \strokec4 * B = (\cf5 \strokec5 float\cf4 \strokec4 *)malloc(width * width * \cf5 \strokec5 sizeof\cf4 \strokec4 (\cf5 \strokec5 float\cf4 \strokec4 ));\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 float\cf4 \strokec4 * C_gpu = (\cf5 \strokec5 float\cf4 \strokec4 *)malloc(width * width * \cf5 \strokec5 sizeof\cf4 \strokec4 (\cf5 \strokec5 float\cf4 \strokec4 ));\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 float\cf4 \strokec4 * C_cpu = (\cf5 \strokec5 float\cf4 \strokec4 *)malloc(width * width * \cf5 \strokec5 sizeof\cf4 \strokec4 (\cf5 \strokec5 float\cf4 \strokec4 ));\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 srand(time(\cf5 \strokec5 NULL\cf4 \strokec4 ));\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 for\cf4 \strokec4  (\cf5 \strokec5 int\cf4 \strokec4  j = \cf7 \strokec7 0\cf4 \strokec4 ; j < width * width; ++j) \{\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 A[j] = (\cf5 \strokec5 float\cf4 \strokec4 )rand() / \cf5 \strokec5 RAND_MAX\cf4 \strokec4 ;\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 B[j] = (\cf5 \strokec5 float\cf4 \strokec4 )rand() / \cf5 \strokec5 RAND_MAX\cf4 \strokec4 ;\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 // Design 1: Each thread produces one output matrix element\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 dim3 gridDim1((width - \cf7 \strokec7 1\cf4 \strokec4 ) / \cf7 \strokec7 16\cf4 \strokec4  + \cf7 \strokec7 1\cf4 \strokec4 , (width - \cf7 \strokec7 1\cf4 \strokec4 ) / \cf7 \strokec7 16\cf4 \strokec4  + \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 dim3 blockDim1(\cf7 \strokec7 16\cf4 \strokec4 , \cf7 \strokec7 16\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Design 1: Each thread produces one output matrix element\\n"\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 matrixAddition(C_gpu, A, B, width, matrix_add_element, gridDim1, blockDim1);\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 //matrixAddition_CPU(C_cpu, A, B, width);\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Test %s\\n"\cf4 \strokec4 , testResults(C_gpu, C_cpu, width) ? \cf6 \strokec6 "PASSED"\cf4 \strokec4  : \cf6 \strokec6 "FAILED"\cf4 \strokec4 );\cb1 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 // Design 2: Each thread produces one output matrix row\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 dim3 gridDim2((width - \cf7 \strokec7 1\cf4 \strokec4 ) / \cf7 \strokec7 16\cf4 \strokec4  + \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 dim3 blockDim2(\cf7 \strokec7 16\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Design 2: Each thread produces one output matrix row\\n"\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 matrixAddition(C_gpu, A, B, width, matrix_add_rows, gridDim2, blockDim2);\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Test %s\\n"\cf4 \strokec4 , testResults(C_gpu, C_cpu, width) ? \cf6 \strokec6 "PASSED"\cf4 \strokec4  : \cf6 \strokec6 "FAILED"\cf4 \strokec4 );\cb1 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 // Design 3: Each thread produces one output matrix column\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 dim3 gridDim3((width - \cf7 \strokec7 1\cf4 \strokec4 ) / \cf7 \strokec7 16\cf4 \strokec4  + \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 dim3 blockDim3(\cf7 \strokec7 16\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 , \cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Design 3: Each thread produces one output matrix column\\n"\cf4 \strokec4 );\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 matrixAddition(C_gpu, A, B, width, matrix_add_cols, gridDim3, blockDim3);\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 printf(\cf6 \strokec6 "Test %s\\n"\cf4 \strokec4 , testResults(C_gpu, C_cpu, width) ? \cf6 \strokec6 "PASSED"\cf4 \strokec4  : \cf6 \strokec6 "FAILED"\cf4 \strokec4 );\cb1 \
\
\
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 free(A);\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 free(B);\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 free(C_gpu);\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \u8194 free(C_cpu);\cb1 \
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \}\cb1 \
\
\
\
\cb3 \uc0\u8194 \u8194 \u8194 \u8194 \u8194 \u8194 \cf5 \strokec5 return\cf4 \strokec4  \cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\
\cb3 \}\cb1 \
\
\
\
\
\
}